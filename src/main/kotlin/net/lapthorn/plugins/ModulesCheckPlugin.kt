/*
 * This Kotlin source file was generated by the Gradle 'init' task.
 */
package net.lapthorn.plugins

import org.gradle.api.GradleException
import org.gradle.api.Plugin
import org.gradle.api.Project
import org.gradle.api.artifacts.result.ResolvedArtifactResult
import java.io.BufferedWriter
import java.io.OutputStreamWriter
import java.nio.file.Files
import java.nio.file.Paths
import java.util.jar.JarFile
import java.util.zip.ZipFile

/**
 * A reporting plugin to check whether dependencies are Java modules, or support OSGi.
 */
class ModulesCheckPlugin : Plugin<Project> {
    override fun apply(project: Project) {
        // Register a task
        project.tasks.register("modules-check") { task ->
            // Recurse through all dependencies by default
            val recursive = project.properties["modules-check.recursive"]
                    ?.toString()?.toBoolean() ?: true

            // The configuration we're going to check.
            val cfgName = project.properties["modules-check.configurationName"]
                    ?.toString() ?: "default"

            // Output file.  Attempts to output by file suffix. Defaults to csv, null = stdout.
            val outputFile = project.properties["modules-check.outputFile"]
                    ?.toString()

            task.doLast {
                // Collection of projects to inspect (or just the one main project),
                val projects = if (recursive) {
                    // Subprojects AND parent
                    project.subprojects.apply { add(project) }
                } else {
                    setOf(project)
                }

                val results = mutableListOf<Result>()
                for (subproject in projects) {
                    val requestedConfiguration = subproject.configurations.find {
                        it.isCanBeResolved && it.name == cfgName
                    }

                    if (requestedConfiguration == null) {
                        val cfgs = subproject.configurations
                                .filter { it.isCanBeResolved }
                                .joinToString(prefix = "[", postfix = "]") { it.name }

                        throw GradleException("Config $cfgName does not exist in $cfgs")
                    }

                    results.addAll(checkModules(requestedConfiguration.incoming.artifacts.artifacts))
                }

                writeResults(outputFile, results)
            }
        }
    }

    private fun writeResults(outputFile: String?, results: List<Result>) {
        // If no file, write csv to stdout
        val writer = if (outputFile == null) {
            BufferedWriter(OutputStreamWriter(System.out))
        } else {
            val path = Paths.get(outputFile)
            Files.createDirectories(path.parent)
            Files.newBufferedWriter(path)
        }

        val extension = if (outputFile == null) "csv" else Paths.get(outputFile).toFile().extension

        val sortedResults = results.toList()
                .sortedBy { o -> o.artifact.id.componentIdentifier.displayName }

        writer.use {
            when (extension) {
                "md" -> writeMarkdown(it, sortedResults)
                "markdown" -> writeMarkdown(it, sortedResults)
                else -> writeCsv(it, sortedResults)
            }
        }
    }

    private fun writeCsv(writer: BufferedWriter, results: List<Result>) {
        writer.write("jar,isMultiRelease,isOsgi,hasModuleInfo,AutomaticModuleName\n")
        results.map { o ->
            val s = o.artifact.id.componentIdentifier.displayName
            val jpms = o.hasModuleInfo || o.automaticModuleName.isNotBlank()
            "$s,${o.isOSGi.yes()},${jpms.yes()},${o.isMultiReleaseJar.yes()},${o.hasModuleInfo.yes()},${o.automaticModuleName}\n"
        }.sorted().toSet().forEach { writer.write(it) }
    }

    fun Boolean.yes(): String = if (this) "YES" else ""

    private fun writeMarkdown(writer: BufferedWriter, results: List<Result>) {
        writer.write("jar|OSGI|JPMS|multi-release|`module-info.class`|`Automatic-Module-Name`\n")
        writer.write(":--|:--:|:--:|:-----------:|:-----------------:|:---------------------:\n")
        results.map { o ->
            val s = o.artifact.id.componentIdentifier.displayName
            val jpms = o.hasModuleInfo || o.automaticModuleName.isNotBlank()
            "$s|${o.isOSGi.yes()}|${jpms.yes()}|${o.isMultiReleaseJar.yes()}|${o.hasModuleInfo.yes()}|${o.automaticModuleName}\n"
        }.sorted().toSet().forEach { writer.write(it) }
    }

    data class Result(val artifact: ResolvedArtifactResult,
                      val isOSGi: Boolean,
                      val automaticModuleName: String,
                      val hasModuleInfo: Boolean,
                      val isMultiReleaseJar: Boolean
    )

    private fun checkModules(artifacts: Set<ResolvedArtifactResult>): List<Result> {
        val jars = artifacts.filter { it.file.exists() && it.file.name.endsWith(".jar") }

        return jars.map { inspectJar(it) }
    }

    private fun inspectJar(jar: ResolvedArtifactResult): Result {
        val jarFile = JarFile(jar.file).let {
            if (it.isMultiRelease) {
                JarFile(jar.file, false, ZipFile.OPEN_READ, Runtime.version())
            } else {
                it
            }
        }

        val automaticModuleName = jarFile.manifest.let {
            it.mainAttributes.getValue("Automatic-Module-Name") ?: ""
        }

        val isOSGi = jarFile.manifest.mainAttributes
                .mapKeys { it.toString() }
                .filterKeys { it.contains("Bundle-") }
                .isNotEmpty()

        val hasModuleInfo = jarFile.entries().toList()
                .any { !it.isDirectory && it.name.contains("module-info.class") }

        return Result(jar, isOSGi, automaticModuleName, hasModuleInfo, jarFile.isMultiRelease)
    }
}
